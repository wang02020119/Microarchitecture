SiliFuzz针对**电路缺陷**而不是**逻辑漏洞**进行检测。

- 逻辑漏洞：指定的CPU微架构或者版本固有的异常CPU行为。

- 电路缺陷：只在一个或几个核心上发生的CPU异常行为（也有可能是因为磨损造成的）。

电路缺陷可能只影响到某个物理核，可能出厂时候就有，也可能是物理磨损的结果。



提出一个概念（Silent Data Corruption, SDC ），这样的缺陷（或漏洞）不会立刻导致可观测的崩溃，而是无声 的导致计算错误。



基本方法：使用软件CPU模拟器和反汇编器进行覆盖率引导的模糊测试，生成语料库。 差分测试，在不同CPU核心上测试。



### SiliFuzz Overview

由以下组件组成

- **Snapshot，快照 (§2.2)**: 一种用于表示和序列化简短、独立程序及其参考输出的格式。
- **播放器 (§2.3)**: 一个逐个在CPU或模拟器上执行快照的程序。
- **快照生成 (§2.4)**: 一个用于生成快照集的流程，目的是覆盖尽可能多的边缘情况。
- **执行 (§2.5)**: 一个用于检查每台机器的每个核心的系统。
- **反馈循环 (§2.6)**: 一个在已知有问题的机器与SiliFuzz之间的反馈循环。

SiliFuzz完全在用户空间中工作，因此不会直接测试特定于内核的指令。



### Fuzzing and Coverage

- blackbox fuzzing：随机创建无限数量的测试输入，通常基于输入语法的知识。每个新输入都是从头开始生成的，不使用来自被测试系统的任何反馈。

- graybox fuzzing：基于覆盖引导的变异模糊测试从一组测试输入的初始语料库开始，对语料库中的随机元素应用小的随机变异和交叉操作。变异后的输入由目标应用程序执行，并收集其覆盖反馈。如果某个变异触发了之前未见过的覆盖路径，则将其添加到语料库中。

- structure-aware fuzzing：覆盖引导模糊测试的一种变体，要求对输入进行变异时保持其有效性和语法正确性。

### Snapshot

快照描述了短二进制代码序列的**指令和数据**，要求不包括系统调用，并只在单线程中执行。

一个快照由以下部分组成：

- 所有用户可读CPU寄存器的初始状态，包括程序计数器。
- 内存映射及其读/写/执行权限和相应的数据字节。需要注意的是，预期会引发页面错误的快照要求特定页面未被映射。
- 执行的预期结束状态。如果快照在不同的CPU微架构上执行结果不同，则它将有多个结束状态。如果执行引发CPU异常，则会捕获相应的信号编号和信号地址。
- 额外的元数据，描述该快照的生成方式（例如，它是从程序中捕获的，还是通过组合多个快照生成的，等等）。

### Player

播放器负责重放快照，捕捉结果，并决定是否与预期结束状态之一。如果结果不匹配，则表明执行快照的CPU核心可能存在潜在缺陷。

考虑一个由单条NOP指令组成的简单快照，放置在内存地址0x10000000处。这将触发驱动程序生成以下命令序列，并由控制程序执行：

![image-20241010154307319](C:\Users\王佳顺\Desktop\周五学术日\SiliFuzz\picture1.png)

\xCC字节是x86架构中的陷阱指令，用于标记快照的结束。0x10000000处内存页的其余部分填充为零，以确保执行的确定性。

### Snapshot Generation

SiliFuzz 利用开源的 x86_64 CPU 模拟器和反汇编器作为代理，并借助 libFuzzer 来生成快照。

#### XED

XED是一个x86_64命令加密器和解码器。将XED嵌入进libFuzzer中。

#### ifuzz

ifuzz提供了针对 x86_64 指令的生成和变异功能。在生成模式下，ifuzz 只会创建随机的有效指令序列。由于 ifuzz 不受覆盖率的引导，它会生成无限数量的输出。

将 ifuzz 生成的指令序列样本用于两种方式：首先，我们从中创建快照并在真实 CPU 上测试；其次，我们将它们用作模糊测试 Unicorn 的字典。

#### Unicorn

#### Snapshot Fixing and End State Recording

通过 XED、ifuzz 和 Unicorn 进行的模糊测试不会直接生成快照，而是生成指令序列。我们应用了一系列技术将这些指令序列转换为合适的快照

1. **添加和移除内存映射**：我们拦截内存页面错误，并映射快照访问的有限数量的额外页面。当前映射的页面填充为零。
   
2. **消除非确定性**：通过跟踪所有快照，我们消除所有系统调用。然后验证每个快照能在多台机器上成功并确定性地多次重放。默认情况下，每个快照的CPU时间限制为3秒。

3. **确定结束状态**：最后，每个快照会在所有支持的Google生产平台（不同微架构）上运行，捕获各个平台的结束状态。目前，我们只保留在所有微架构上具有相同结束状态的快照，以进一步防止难以检测的非确定性来源。
